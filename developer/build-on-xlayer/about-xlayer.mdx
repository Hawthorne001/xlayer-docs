# X Layer overview

X Layer is a cutting-edge Ethereum layer 2 (L2) network built by OKX and Polygon using Polygon's CDK. Following the PP upgrade completed on August 5, 2025, it now supports throughput of up to 5,000 TPS with negligible gas fees. It offers full compatibility with the Ethereum Virtual Machine (EVM), enabling developers to deploy existing Ethereum applications and develop new, innovative projects at a fraction of the cost compared to doing so on Ethereum. X Layer also enables users to use dapps at significantly lower gas fees and faster speed compared to Ethereum.

X Layer executes and validates transactions on an EVM, with state and data maintained off‑chain. Routine L2 execution is EVM‑native; Polygon’s Pessimistic Proof (PP) is invoked only for bridging/cross‑domain settlement to provide verifiable finality on L1 or other domains. This contrasts with ZK/OP rollups where L1 data publication is part of the base protocol.

For more detailed information, you can check out the X Layer architecture below.

## X Layer architecture
The major components of X Layer are:
- **Virtual Machine**: EVM‑equivalent
- **Sequencer**: Trusted (implemented by op-node in sequencer mode, coordinating with op-geth via Engine API)
- **Gas token**: OKB (fixed supply at 21M post-burns/upgrades; L1 OKB phased out)


## Background
X Layer has evolved to adopt the Optimism Stack (OP Stack) framework, a battle-tested and widely adopted Layer 2 scaling solution. In this architecture, L2 operates with optimistic assumptions where transactions are considered valid by default, with a 7-day challenge period for fraud proofs. This provides a more efficient and cost-effective solution while maintaining Ethereum's security guarantees through cryptographic fraud proofs when needed.

## Architecture flow (OP Stack + AggLayer mode)

### L1 → L2 Bridge Flow (via AggLayer)

- 1.1 User deposits assets on L1 bridge contract (bridgeAsset call)
- 1.2 L1 bridge contract emits BridgeEvent and updates GlobalExitRoot (GER)
- 1.3 L1InfoTreeSyncer monitors L1 events and updates L1 Info Tree
- 1.4 AggOracle fetches finalized GER from L1 and injects it into L2 GlobalExitRootManager contract
- 1.5 User calls claimAsset on L2 (via Proxyd → op-geth RPC) with Merkle proof
- 1.6 op-geth adds claim transaction to TxPool
- 1.7 op-node (sequencer) triggers block building via Engine API (ForkchoiceUpdate)
- 1.8 op-geth executes claim transaction from TxPool and credits user account
- 1.9 op-node continues producing L2 blocks every 2 seconds
- 1.10 RPC nodes expose updated balance/status to users

### L2 → L1 Bridge Flow (via AggLayer)

- 2.1 User initiates bridge withdrawal on L2 (bridgeAsset call via Proxyd → op-geth RPC)
- 2.2 op-geth adds transaction to TxPool
- 2.3 op-node (sequencer) triggers block building via Engine API
- 2.4 op-geth executes bridge transaction, emits BridgeEvent, and updates Local Exit Root (LER)
- 2.5 L2BridgeSyncer monitors L2 bridge events and updates local exit tree
- 2.6 op-batcher collects L2 transactions and submits compressed batches to L1
- 2.7 op-proposer periodically submits L2 state roots to L1 (every 2 minutes)

### Certificate & Pessimistic Proof Settlement

- 3.1 AggSender waits for epoch trigger
- 3.2 AggSender fetches bridges/claims from L2BridgeSyncer and constructs Certificate:
  - NetworkID: X Layer's rollup ID
  - BridgeExits: L2→L1 bridges (updates LER)
  - ImportedBridgeExits: L1→L2 claims with Merkle proofs
- 3.3 AggSender signs and submits Certificate to AggLayer
- 3.4 AggLayer coordinates ZK proof generation (via agglayer-prover)
- 3.5 AggLayer submits proof + public inputs to L1 RollupManager contract
- 3.6 L1 verifies proof and updates GlobalExitRoot
- 3.7 After verification, withdrawals achieve L1 finality (Certificate status: Settled)

### Continuous Synchronization

- 4.1 L2BridgeSyncer continuously monitors L2 bridge/claim events
- 4.2 L1InfoTreeSyncer continuously monitors L1 GER updates and RollupManager events
- 4.3 AggOracle periodically injects finalized GER from L1 to L2

Outcome: Fast execution happens on L2 with 2-second block times; for withdrawals, users wait for the 7-day challenge period to ensure security. All L2 data is published to L1, ensuring the system is fully trustless and censorship-resistant.

This flow ensures immediate transaction finality on L2 for most operations while providing cryptographic security for cross-chain operations through the optimistic rollup model.

## Pessimistic Proofs (PP) overview
X Layer is built with Polygon CDK, an open‑source framework for EVM L2s on [Ethereum](https://ethereum.org/en/ "Ethereum"). For cross‑chain operations (e.g., withdrawals and bridge messages), X Layer leverages Polygon's Pessimistic Proof (PP). PP produces a succinct proof that the claimed state transition is valid with respect to L2, enabling secure settlement on L1 without publishing full L2 transaction data.

## How L1 settlement works
A verifier/bridge smart contract is deployed on Ethereum. For cross‑chain operations, the Polygon‑side `agglayer` submits a PP (ZK) certificate/proof to this contract on behalf of X Layer. The proof attests to the L2 state transition result but not the full transaction data. The verifier contract checks the validity of the submitted PP; invalid submissions are rejected and not processed on Ethereum.

## Consensus & finality
Transactions are executed by the EVM and finalized on L2 by the trusted sequencer set. Cross‑chain finality is handled by the Polygon‑side `agglayer` subsystem: xlayer generates and stores certificate data (metadata/epochs), `aggsender` syncs and submits certificates to `agglayer`, and `agglayer`/`agglayer‑prover` submits PP proofs on L1. The two key flows are: **L2 block production & data writes** and **cross‑chain certificate + PP submission**. Participants include **Sequencer** and the **aggsender/agglayer** pipeline.

**Sequencer**: responsible for batching transactions on L2, producing blocks, and writing chain data.

**aggsender/agglayer**: `aggsender` fetches blocks/certificates from the node side, performs double‑check, and syncs the certificate to `agglayer`; `agglayer` (with `agglayer‑prover`) submits PP proofs on L1 to complete cross‑chain settlement.


## Data model and settlement
X Layer stores transaction data and state off‑chain and uses PP only to settle cross‑chain operations on L1. This design keeps fees low and throughput high while still providing verifiable finality for bridge operations via proofs. 

## X Layer node
The X Layer node (based on `xlayer-erigon`) syncs with the L2 state. Trusted sequencers are responsible for managing L2 state and batching, while cross‑chain finality is handled by PP.

<Tip title="Note">For node internals and configuration, see the `xlayer-erigon` repository.</Tip>

## Pessimistic Proofs (PP) for cross‑chain
For bridging and cross‑domain settlement, X Layer integrates Polygon's Pessimistic Proofs. During a withdrawal or cross‑chain message, an aggregator produces a PP that attests to the L2 state at a given checkpoint. This proof is verified by the L1 bridge/verifier contract before funds/messages are released on L1. PP is not used for day‑to‑day L2 transaction execution.

## Transactions on X Layer
Layer 2 transactions:
  - A user sends a transaction from their wallet to the network via Proxyd/RPC; the Sequencer includes it in an L2 block.
  - Once the Sequencer commits the block, the transaction is finalized on L2 (execution and fees are enforced on L2).
  - For cross‑chain actions (withdrawals, bridge messages), xlayer produces a certificate; `aggsender` submits the certificate to `agglayer`.
  - `agglayer`/`agglayer‑prover` generates a Pessimistic Proof (PP) and submits it to the L1 verifier/bridge contract.
  - After the PP is verified on L1, the cross‑chain operation reaches L1 finality. Day‑to‑day L2 transactions do not require PP.