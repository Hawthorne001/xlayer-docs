# X Layer overview

X Layer is a cutting-edge Ethereum layer 2 (L2) network built by OKX and Polygon using Polygon's CDK. Following the PP upgrade completed on August 5, 2025, it now supports throughput of up to 5,000 TPS with negligible gas fees. It offers full compatibility with the Ethereum Virtual Machine (EVM), enabling developers to deploy existing Ethereum applications and develop new, innovative projects at a fraction of the cost compared to doing so on Ethereum. X Layer also enables users to use dapps at significantly lower gas fees and faster speed compared to Ethereum.

X Layer executes and validates transactions on an EVM, with state and data maintained off‑chain. Routine L2 execution is EVM‑native; Polygon’s Pessimistic Proof (PP) is invoked only for bridging/cross‑domain settlement to provide verifiable finality on L1 or other domains. This contrasts with ZK/OP rollups where L1 data publication is part of the base protocol.

For more detailed information, you can check out the X Layer architecture below.

## X Layer architecture
The major components of X Layer are:
- **Virtual Machine**: EVM‑equivalent
- **Sequencer**: Trusted (implemented by op-node in sequencer mode, coordinating with op-geth via Engine API)
- **Gas token**: OKB (fixed supply at 21M post-burns/upgrades; L1 OKB phased out)


## Background
X Layer has evolved to adopt the Optimism Stack (OP Stack) framework, a battle-tested and widely adopted Layer 2 scaling solution. In this architecture, L2 operates with optimistic assumptions where transactions are considered valid by default, with a 7-day challenge period for fraud proofs. This provides a more efficient and cost-effective solution while maintaining Ethereum's security guarantees through cryptographic fraud proofs when needed.

## Architecture flow (OP Stack mode)
Starting from the user deposit on L1:

- 1.x L1 deposit → credit on L2 (bridge in)
  - 1.1 User deposits assets on L1 bridge contract (OptimismPortal)
  - 1.2 op-node (sequencer) monitors L1 contract events and derives deposit transactions
  - 1.3 op-node (sequencer) includes deposit transaction in L2 block via Engine API
  - 1.4 op-geth (execution engine) executes the deposit and credits user account
  - 1.5 op-node (sequencer) continues producing L2 blocks every 2 seconds
  - 1.6 RPC nodes expose the updated balance/status to users
- 2.x L2 user Tx & withdrawal (L2 → L1)
  - 2.1 User initiates withdrawal on L2; op-geth processes the transaction
  - 2.2 Withdrawal is recorded in L2ToL1MessagePasser contract
  - 2.3 op-batcher collects transactions and submits compressed batches to L1
  - 2.4 op-proposer periodically submits L2 state roots to L1 (every 2 minutes)
- 3.x Challenge period & finalization on L1
  - 3.1 State root enters 7-day challenge period on L1
  - 3.2 op-challenger monitors all proposals for invalid states
  - 3.3 If invalid state detected, challenger initiates dispute game
  - 3.4 Fault proof (via op-program) determines the correct state through bisection
  - 3.5 After challenge period expires, withdrawal can be finalized on L1
- 4.x Data availability & verification
  - 4.1 op-batcher publishes transaction data via EIP-4844 blobs or calldata
  - 4.2 Anyone can reconstruct L2 state from L1 data
  - 4.3 op-conductor ensures high availability with automatic failover (enterprise feature)

Outcome: Fast execution happens on L2 with 2-second block times; for withdrawals, users wait for the 7-day challenge period to ensure security. All L2 data is published to L1, ensuring the system is fully trustless and censorship-resistant.

This flow ensures immediate transaction finality on L2 for most operations while providing cryptographic security for cross-chain operations through the optimistic rollup model.
